import inspect
import logging
from typing import Iterable

import pulumi
import ray
from pulumi import automation as auto


from buildflow.core.options.infra_options import PulumiOptions
from buildflow.core.io.providers._provider import Provider
import dataclasses
from buildflow.config.pulumi_config import PulumiConfig
import re


import os
from typing import Mapping


from buildflow import utils


@dataclasses.dataclass
class PulumiWorkspace:
    pulumi_workspace_dir: str
    pulumi_config: PulumiConfig

    def get_config(self) -> PulumiConfig:
        return self.pulumi_config

    def stack_name(self) -> str:
        return self.pulumi_config.stack_name

    def project_name(self) -> str:
        return self.pulumi_config.project_name

    def workspace_id(self) -> str:
        return f"{self.pulumi_config.project_name}:{self.pulumi_config.stack_name}"

    def env_vars(self) -> Mapping[str, str]:
        return {
            "PULUMI_CONFIG_PASSPHRASE": self.pulumi_config.passphrase,
        }

    def stack_settings(self) -> auto.StackSettings:
        return auto.StackSettings(
            secrets_provider=None,
            encrypted_key=None,
            encryption_salt=None,
            # TODO: Set this using the ResourceConfig type
            config={"gcp:project": "TODO"},
        )

    def project_settings(self) -> auto.ProjectSettings:
        return auto.ProjectSettings(
            name=self.project_name(),
            runtime="python",
            main=None,
            description="Pulumi Project generated by Buildflow",
            author=None,
            website=None,
            license=None,
            config=None,
            template=None,
            backend=auto.ProjectBackend(self.pulumi_config.backend_url),
        )

    def workspace_options(self) -> auto.LocalWorkspaceOptions:
        return auto.LocalWorkspaceOptions(
            work_dir=self.pulumi_config.pulumi_home,
            pulumi_home=self.pulumi_config.pulumi_home,
            # NOTE: we set the program as None here because we will be using an inline
            # `pulumi_program` function to dynamically create the program at runtime.
            program=None,
            env_vars=self.env_vars(),
            # TODO: add support for `secrets_provider`
            secrets_provider=None,
            project_settings=self.project_settings(),
            stack_settings={self.stack_name(): self.stack_settings()},
        )

    @classmethod
    def create(cls, pulumi_workspace_dir: str) -> "PulumiWorkspace":
        # create the default pulumi config
        pulumi_config_path = os.path.join(pulumi_workspace_dir, "config.json")
        pulumi_config = PulumiConfig.default(pulumi_workspace_dir)
        pulumi_config.dump(pulumi_config_path)
        # return the pulumi workspace
        return cls(pulumi_workspace_dir, pulumi_config)

    @classmethod
    def load(cls, pulumi_workspace_dir: str) -> "PulumiWorkspace":
        utils.assert_path_exists(pulumi_workspace_dir)
        # load the pulumi config
        pulumi_config_path = os.path.join(pulumi_workspace_dir, "config.json")
        pulumi_config = PulumiConfig.load(pulumi_config_path)
        # return the pulumi workspace
        return cls(pulumi_workspace_dir, pulumi_config)

    def save(self):
        # save the pulumi config
        pulumi_config_path = os.path.join(self.pulumi_workspace_dir, "config.json")
        self.pulumi_config.dump(pulumi_config_path)


# Pulumi will log this error that we want to catch:
# A new version of Pulumi is available. To upgrade from version '3.68.0' to '3.73.0', run
# $ curl -sSL https://get.pulumi.com | sh
# or visit https://pulumi.com/docs/reference/install/ for manual instructions and release notes.
def _remove_pulumi_upgrade_error_from_logs(stderr: str):
    # The regular expression .* does not match newline characters by default.
    # flags=re.DOTALL makes . the re expression match any character including a newline
    pattern = re.compile(
        r"warning: A new version of Pulumi is available.*release notes\.",
        flags=re.DOTALL,
    )
    return pattern.sub("", stderr).strip()


# Each log replacement rule should have its own function
def _clean_stderr(stderr: str):
    stderr = _remove_pulumi_upgrade_error_from_logs(stderr)
    return stderr


# logs look like:
#   +  gcp:pubsub:Subscription buildflow_subscription_43c1269c create
#   +  gcp:bigquery:Table daring-runway-374503.buildflow.table_9312c458 create
#  @ previewing update....
#   +  pulumi:pulumi:Stack buildflow-app-buildflow-stack create
#
#  Outputs:
#      gcp.bigquery.dataset_id     : "daring-runway-374503.buildflow"
#      gcp.biquery.table_id        : "daring-runway-374503.buildflow.table_9312c458"
#      gcp.pubsub.subscription.name: "buildflow_subscription_43c1269c"
#
#  Resources:
#      + 4 to create
def extract_outputs_from_stdout(stdout: str):
    pattern = re.compile(r"Outputs:\n((?:\s{4}.+\n)+)")
    match = pattern.search(stdout)
    if match:
        outputs = match.group(1)
        outputs = outputs.strip()
        outputs = outputs.split("\n")
        outputs = [output.strip() for output in outputs]
        outputs = [output.split(":") for output in outputs]
        outputs = {key.strip(): value.strip() for key, value in outputs}
        return outputs
    else:
        return {}


@dataclasses.dataclass
class WrappedRefreshResult:
    refresh_result: auto.RefreshResult

    def log_summary(self):
        logging.debug(self.refresh_result.stdout)
        if self.refresh_result.stderr:
            logging.error(self.refresh_result.stderr)
        logging.debug(self.refresh_result.summary)


@dataclasses.dataclass
class WrappedPreviewResult:
    preview_result: auto.PreviewResult

    def __post_init__(self):
        self.preview_result.stderr = _clean_stderr(self.preview_result.stderr)

    def log_summary(self):
        logging.debug(self.preview_result.stdout)
        if self.preview_result.stderr:
            logging.error(self.preview_result.stderr)
        logging.debug(self.preview_result.change_summary)

    def print_change_summary(self):
        num_to_create = self.preview_result.change_summary.get("create", 0)
        resource_outputs = extract_outputs_from_stdout(self.preview_result.stdout)
        resource_outputs_str = "\n".join(
            [
                f"    {output_key}:{output_value}"
                for output_key, output_value in resource_outputs.items()
            ]
        )
        lines = [
            "-" * 80,
            f"Number of Resources to create: {num_to_create}",
            "",
            f"Resource Outputs:",
            resource_outputs_str,
            "-" * 80,
        ]
        print("\n".join(lines))


@dataclasses.dataclass
class WrappedUpResult:
    up_result: auto.UpResult

    def log_summary(self):
        logging.warning(self.up_result.stdout)
        if self.up_result.stderr:
            logging.error(self.up_result.stderr)
        logging.warning(self.up_result.summary)
        logging.warning(self.up_result.outputs)


@dataclasses.dataclass
class WrappedDestroyResult:
    destroy_result: auto.DestroyResult

    def log_summary(self):
        logging.warning(self.destroy_result.stdout)
        if self.destroy_result.stderr:
            logging.error(self.destroy_result.stderr)
        logging.warning(self.destroy_result.summary)


@dataclasses.dataclass
class WrappedOutputMap:
    output_map: auto.OutputMap

    def log_summary(self):
        logging.warning(self.output_map)

    def print_summary(self):
        print(self.output_map)


@ray.remote
class PulumiWorkspaceActor:
    def __init__(self, pulumi_options: PulumiOptions) -> None:
        # NOTE: Ray actors run in their own process, so we need to configure
        # logging per actor / remote task.
        logging.getLogger().setLevel(pulumi_options.log_level)

        # set options
        self.options = pulumi_options
        # initial state
        # TODO: Create if this doesnt exist
        self._workspace = PulumiWorkspace.load(
            "/home/tanke/launchflow/buildflow/.buildflow/pulumi"
        )
        self._pulumi_program_cache = {}

    async def refresh(self, *, providers: Iterable[Provider]) -> WrappedRefreshResult:
        logging.debug(f"Pulumi Refresh: {self._workspace.workspace_id()}")
        stack = self._create_or_select_stack(providers)
        return WrappedRefreshResult(refresh_result=stack.refresh())

    async def preview(self, *, providers: Iterable[Provider]) -> WrappedPreviewResult:
        logging.debug(f"Pulumi Preview: {self._workspace.workspace_id()}")
        stack = self._create_or_select_stack(providers)
        if self.options.refresh_state:
            stack.refresh()
        return WrappedPreviewResult(preview_result=stack.preview())

    async def up(self, *, providers: Iterable[Provider]) -> WrappedUpResult:
        logging.debug(f"Pulumi Up: {self._workspace.workspace_id()}")
        stack = self._create_or_select_stack(providers)
        if self.options.refresh_state:
            stack.refresh()

        return WrappedUpResult(up_result=stack.up())

    async def outputs(self, *, providers: Iterable[Provider]) -> WrappedOutputMap:
        logging.debug(f"Pulumi Outputs: {self._workspace.workspace_id()}")
        stack = self._create_or_select_stack(providers)
        return WrappedOutputMap(output_map=stack.outputs())

    async def destroy(self, *, providers: Iterable[Provider]) -> WrappedDestroyResult:
        logging.debug(f"Pulumi Destroy: {self._workspace.workspace_id()}")  # noqa: E501
        stack = self._create_or_select_stack(providers)
        return WrappedDestroyResult(destroy_result=stack.destroy())

    def _create_pulumi_program(self, providers: Iterable[Provider]):
        def pulumi_program():
            for provider in providers:
                # Fetch the Pulumi Resources from the provider (if any).
                # NOTE: We set the type_ to None because the Flow decorator should
                # have already wrapped the types in a nested pulumi_resources function.
                provider.pulumi_resources(type_=None)

        return pulumi_program

    def _create_or_select_stack(self, providers: Iterable[Provider]):
        if self._workspace.workspace_id() not in self._pulumi_program_cache:
            pulumi_program = self._create_pulumi_program(providers)
            self._pulumi_program_cache[self._workspace.workspace_id()] = pulumi_program
        else:
            pulumi_program = self._pulumi_program_cache[self._workspace.workspace_id()]

        return auto.create_or_select_stack(
            stack_name=self._workspace.stack_name(),
            project_name=self._workspace.project_name(),
            program=pulumi_program,
            opts=self._workspace.workspace_options(),
        )
